package com.jaaaelu.gzw.design.patterns.iteratorAndCombinationPattern;

public class IteratorAndCombinationPattern {
    //  第九章 迭代器与组合模式

    //  本章我们将学到如何让你的客户端遍历你的对象而又法务窥视你存储对象的方式；也将学到如何创建一些对象超集合，能够一口
    //  气就跳过某些让人望而生畏的数据结构；以及还将学到一些关于对象职责的知识

    //  迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示

    //  把遍历的任务放在迭代器上，而不是聚合（容器对象）上。这样简化了聚合的接口和实现，也让责任各得其所。我们也就无需关
    //  心我们遍历到底是数组还是 List 或者其他对象了

    //  设计原则
    //  1.单一原则：一个类应该只有一个引起变化的原因（类的每个责任都有改变的潜在区域。超过一个责任，意味着超过一个改变的区域）
    //  这个原则告诉我们，尽量让类保持单一职责

    //  当一个模块或一个类被设计成只支持一组相关功能时，我们说它具有高内聚；反之，当被设计成支持一组不相关的功能时，我们
    //  说它具有低内聚

    //  我们第一个版本的菜单是基于菜单接口定义出一套菜单规范，然后我们可以通过遍历菜单容器拿到具体的某一份菜单，然后再通
    //  过遍历具体菜单拿到具体的食品信息，现在需求需要改变了，我想要在菜单中插入子菜单，比如午餐菜单中有甜品的子菜单，这
    //  时候，我们的数据结构就成了，一个节点下面有若干子节点，有些子节点下面还可以对应的自己的子节点

    //  组合模式：允许你将对象组成树形结构来表现“整体/部分”层次结构。组合能让客户端以一致的方法处理个别对象以及对象组合

    //  这个模式能够创建一个树形结构，在同一个结构中处理嵌套菜单和菜单项组

    //  使用组合结构，我们能把相同的操作应用在组合和个别对象。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象的差别（？）

    //  我们前面学习了单一原则，但是现在组合模式不仅要管理层次结构，而且还要执行对应的菜单操作，这看上去是违反了单一原则，
    //  书中说到组合模式是以单一职责原则换取透明性。什么是透明性？通过让组件的接口包含一些管理子节点和叶节点（没有子元素）
    //  的操作，客户就可以将组合和叶节点一视同仁。也就是说，一个元素究竟是组合还是叶节点，对客户是透明的

    //  尽管我们受到了设计原则的指导，但是，我们总是需要观察某原则对我们的设计造成的影响。有些时候，我们会故意做一些看似
    //  违反原则的事情

    //  当你有数个对象的集合，它们彼此之间有个“整体/部分”的关系，并且你想用一致的方式对待这些对象时，你就可以使用组合模
    //  式
    //  “整体/部分”就像是我们 Android 中的布局，父布局里面可以有子节点或是叶节点，而子节点又可以有自己的节点
    //  我们称这种包含其他组件的组件为组合对象，而称没有包含其他组件的组件为叶节点对象
    //  “用一致的方式对待”表明组合和叶节点之间具有共同的方法，也就是继承了同一接口，但这意味每一个对象都有了相同的接口，
    //  但可能组合中的某些对象行为不太一样。这里的取舍就是为了保持透明性，组合内的所有对象必须都实现相同的接口，否则客户
    //  端就必须操心哪个对象用哪个接口，这就失去了组合模式的意义。当然这就是说有些对象具备一些没有意义的方法调用

    //  有时如果组合结构很复杂，或者遍历的代价太大，你可以使用缓存，来临时保存结果

    //  连连看总结（书中的连连看）：
    //  - 策略：封装可互换的行为，并使用委托决定使用哪一个
    //  - 适配器：改变一个类或多个类的接口
    //  - 迭代器：提供一个方法来遍历集合，而无须暴露集合的实现
    //  - 外观：简化一群类的接口
    //  - 组合：客户端可以将对象的集合以及个别的对象一视同仁
    //  - 观察者：当某个状态改变时，允许一群对象能被通知到

    //  要点：
    //  - 迭代器允许访问聚合的元素，而不需要暴露它的内部结构
    //  - 迭代器将遍历聚合的工作封装在一个对象中
    //  - 当使用迭代器的时候，我们依赖聚合提供遍历
    //  - 迭代器提供了一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多态的机制
    //  - 我们应该努力上一个类子分配一个责任
    //  - 组合模式提供一个结构，可同时包容个别对象和组合对象
    //  - 组合模式允许客户对个别对象以及组合对象一视同仁
    //  - 组合结构内的任意对象成为组件，组件可以是组合（子节点），也可以是叶节点（没有子元素）
    //  - 在实现组合模式时，有许多设计上的折衷。你要根据需要平衡透明和安全性

}
