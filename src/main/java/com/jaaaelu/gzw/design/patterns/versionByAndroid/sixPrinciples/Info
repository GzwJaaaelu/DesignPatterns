1.单一职责原则（SRP）——优化代码第一步
 - 就一个类而言，应该仅有一个引起它变化的原因
 - 简单来说，一个类中应该是一组相关性很高的函数、数据的封装
 - 当然，最大的问题也就是对职责的定义，什么是类的职责，已经怎么划分类的职责
2.开闭原则（OCP）——让程序更稳定、更灵活
 - 软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的
 - 在软件的声明周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会将错误硬迁入原本已经通过测试的旧代码
 中，破坏原有系统。因此，但软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修过修改已有代码来实现。不过这
 种是较为理想的情况，实际开发中，修改原有代码、扩展代码往往是同时存在的
 - 软件开发中，最不会变化的是变化本身
 - 在开发过程中，需要自己结合具体的情况进行考量，是通过修改旧代码还是通过集成使得软件系统更稳定、更灵活，在保证去除“代码
 腐化”的是同时，也保证原有模块的正确性
3.里氏替换原则（LSP）——构建扩展性更好的系统
 - 第一种定义（复杂版）：如果对每一个类型的 S 对象 O1，都有类型为 T 的对象 O2，使得以 T 定义的所有程序 P 在所有的对象 O1
 替换成 O2 时，程序 P 的行为都没有发生变化，那么类型 S 是类型 T 的子类型
 - 第二种定义（简化版）：所有引用基类的地方必须能透明的使用其子类
 - 里氏替换原则的核心原理是抽象，抽象又依赖于集成这个特性，不过在面向对象中，继承的优缺点都相当明显：
    - 优点：
        - 代码重用，减少创建类的成本，每个子类都拥有父类的方法和属性
        - 子类与父类基本相似，但又与父类有所不同
        - 提高代码的可扩展性
    - 缺点：
        - 继承是侵入性的，只要集成就必须拥有父类的所有属性和方法
        - 可能造成子类代码冗余、灵活度降低，因为子类必须拥有父类的属性和方法
 - 如何权衡利弊是需要根据具体情况来做出选择并加以处理的
 - 开闭原则和里氏替换原则往往是一同出现的，通过里氏替换来达到对扩展开放，对修关闭的效果，这两个原子能和都强调了抽象的特性，
 在开发过程中运用抽象是走向代码优化的重要一步
4.依赖倒置（DIP）——让项目拥有变化能力
 - 指的是一种特定的解耦形式，使得高层次的模块不依赖于低层次的实现细节的目的，依赖模块被颠倒了
 - 依赖倒置原则的几个关键点
    - 高层模块不应该依赖底层模块，两者都应该依赖其抽象
    - 抽象不应该依赖细节
    - 细节应该依赖抽象
 - Java 中，抽象指的是接口或抽象类，两者都不能直接被实例化；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，细节
 是可以被实例化的
 - 模块间的依赖是通过抽象发生的，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的
5.接口隔离原则（ISP）——系统有更高的灵活性
 - 客户端不应该依赖它不需要的接口
 - 类间的依赖关系应该建立在最小的接口上
 - 接口隔离原则将非常庞大、臃肿的的接口拆分成更小和更具体的接口，目的是让系统解开耦合，从而容易重构、更改和重新部署
 - 例如书中的 CloseUtils 其实就是依赖于 Closeable 抽象而不是具体的实现类，并建立在最小化依赖的原则上，它只需要直到这个对
 象是否是可关闭的，其他一概不关心
6.迪米特原则（LOD）——更好的可扩展性
 - 一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现与调用者或
 依赖者没关系，调用者或依赖者只需要知道它需要的方法即可，其他的可一概不用管。类与类之间的关系越密切，耦合度越大，当一个类
 发生改变时，对另一个类影响也越大
 - “只与直接的朋友通信”，将类从复杂关系网中抽离，使程序耦合度更低、稳定性更好