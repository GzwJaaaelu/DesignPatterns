package com.jaaaelu.gzw.design.patterns.templateMethodPattern;

public class TemplateMethodPattern {
    //  第八章 模板方法模式

    //  我们前面围绕着封装转；包括封装了对象创建、方法调用、复杂接口、鸭子、披萨……
    //  接下来我们来深入学习一下封装算法块

    //   模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现

    //  模板方法模式：在一个放纵定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以再不改变算法结构的情况
    //  下，重新定义算法中的某些步骤

    //  这个模式是用来创建一个算法的模板。什么是模板？如你所见，模板就是一个方法。更具体的说，这个方法将算法定义成一组步
    //  骤，其中的任何步骤都可以是抽象的，由子类负责实现。这可以确保算法的结构保持不变，同时由子类提供给部分实现

    //  通过添加钩子，使其作为条件控制，从而影响抽象类中的算法流程

    //  什么时候该使用抽象方法？什么时候使用钩子呢？
    //  当你子类“必须”提供算法中的某个方法或步骤的实现时，就使用抽象方法（当然我们也应该尽量减少抽象方法的数量）
    //  如果算法的这个部分是可选的，就用钩子

    //  设计原则
    //  1.好莱坞原则：别调用我们，我们会调用你（好莱坞原则可以给我们一种防止“依赖腐败”的方法。高低层级组件互相依赖的时
    //  候，没人可以轻易搞清楚系统是如何设计的）
    //  在好莱坞原则之下，我们允许低层组件将自己挂钩到系统上，但是高层及组件会决定什么时候和怎么样使用这些底层组件。换句
    //  话说，高层组件对待底层组建的方式是“别调用我们，我们会调用你”
    //  我们要做的是，避免高低层级组件之间有明显的环状依赖

    //  低层组件可以参与运算；但高层组件控制何时以及如何让低层组件参与；低层组件绝对不尅直接调用高层组件

    //  好莱坞原则与模板方法：
    //  CaffeineBeverage 是我们的高层组件，它能够控制算法，只有在需要子类实现某个方式，才调用子类。而我们在使用的过程中，
    //  只依赖 CaffeineBeverage 的抽象，而不是具体的 Tea 或者 Coffee，这也减少了整个系统的依赖
    //  除了模板模式，工厂模式、观察者模式也有采用了好莱坞原则，当然还有其他的设计模式

    //  连连看总结（书中的连连看）：
    //  - 模板方法：子类决定如何实现算法中的步骤
    //  - 策略：封装可互换的行为，然后使用委托来决定要采用哪一个行为
    //  - 工厂方法：由子类决定实例化哪个具体类

    //  这个模式很常见是因为对创建框架来说，这个模式简直棒极了（书中原话）。由框架控制如何做事情，而由你（使用这个框架的
    //  人）指定框架算法中每个步骤的细节

    //  当我们来到真实世界时，必须学会找出周围的模式。我们也必须学会识别模式的变体，因为在真实的世界中，正方形并非总是毫
    //  厘不差的

    //  例如作者认为 Arrays 中的 mergeSort(...) 就一个模板方法变体，就是下面这一小段代码，swap 是一个具体方法，定义在 Arrays
    //  中，而 compareTo 方法就需要子类自己实现了

//    if(length < INSERTIONSORT_THRESHOLD) {
//        for (int i = low; i < high; i++)
//            for (int j = i; j > low &&
//                    ((Comparable) dest[j - 1]).compareTo(dest[j]) > 0; j--)
//                swap(dest, j, j - 1);
//        return;
//    }

    //  模板方法的中带你在于提供一个算法，并让子类实现某些步骤而数组排序做法很明显的并非如此，这虽然不是教科书上的模板方
    //  法，但它的实现仍然符合模板方法的精神。再者由于不需要继承数组就可以使用这个算法，这样也使得排序变得更有弹性、更有
    //  用。（在策略模式中，你所组合的类实现了整个算法。数组所实现的排序算法并不完整，它需要一个类填补 compareTo 方法的实
    //  现，所以它更像是模板模式而不是策略模式）

    //  Java 中 InputStream 的 read() 是有子类实现的，而这个方法又会被 read(byte[] b, int off, int len) 模板方法使用

    //  要点：
    //  - “模板方法”定义了算法的步骤，把这些步骤的实现延迟到子类
    //  - 模板方法为我们提供了一种代码复用的重要技巧
    //  - 模板方法的抽象类可以定义具体方法、抽象方法和钩子
    //  - 抽象方法由子类实现
    //  - 钩子是一种方法，它再抽象类中不做事，或者只做默认的事情，子类可以选择要不要覆盖它
    //  - 为了防止子类改变模板方法中的算法，可以将模板方法声明成 final
    //  - 好莱坞原则告诉我们，将决策权放在高层模块中，以便决定如何以及何时调用底层模块
    //  - 你将在真实世界代码中看到模板方法模式的许多变体，不要期待他们全都是一样就可以被你认出的
    //  - 策略模式和模板方法模式都是封装算法，一个用组合，一个用继承
    //  - 工厂方法是模板方法的一种特殊版本
}
