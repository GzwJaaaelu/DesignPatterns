package com.jaaaelu.gzw.design.patterns.versionByHeadFirst.otherPattern;

public class OtherPattern {
    //  附录 A 剩下的模式

    //  1.桥接
    //  使用桥接模式，不止改变你的显示，也改变你的抽象
    //  桥接的优点：
    //  - 将实现予以解耦，让它和看界面之间不再永久绑定
    //  - 抽象与实现可以独立拓展，不会影响到对方
    //  - 对于“具体的抽象类”所做的改变，不会影响到客户
    //  桥接的用途与缺点：
    //  - 适合使用在需要跨越多个平台的图形与窗口系统上
    //  - 当需要用不同的方式改变接口和实现时，你会发现桥接模式很好用
    //  - 桥接模式的缺点是增加了复杂度

    //  2.生成器（Builder）
    //  使用生成器模式封装一个产品的构造过程，并允许按步骤构造
    //  生成器的优点：
    //  - 建一个复杂对象的创建过程封装起来
    //  - 允许对象通过多个步骤来创建，并且可以改变过程（这和只有一个步骤的工厂模式不同）
    //  - 像客户隐藏产品内部的表现
    //  - 产品的实现可以被替换，因为客户只看到一个抽象的接口
    //  生成器的用途与缺点：
    //  - 经常被用来创建组合结构
    //  - 与工厂模式相比，采用生成器模式创建对象的客户，需要具备更多的领域知识

    //  3.责任链
    //  当你想要让你一个以上的对象有机会能够处理某个请求的时候，就使用责任链模式
    //  责任链的优点：
    //  - 将请求的发送者和接收者解耦
    //  - 可以简化你的对象，因为它不需要知道责任链的结构
    //  - 通过改变链内部的成员或调用他们的次序，允许你动态的新增或删除责任
    //  责任链的用途与缺点：
    //  - 经常被使用在窗口系统中，处理鼠标和键盘之类的事件
    //  - 并不保证请求一定会被执行；如果没有任何对象处理它的话，它可能会货到链尾端之外（这可以是优点也可以是缺点）
    //  - 可能不容易观察运行时的特征，有碍于除错

    //  4.蝇量
    //  如果想让某个类的一个实例能用来提供许多“虚拟实例”，就使用蝇量模式
    //  蝇量的优点：
    //  减少运行时对象实例的个数，节省内存
    //  将许多“虚拟”对象的状态集中管理
    //  蝇量的用途和缺点
    //  当一个类有许多的实例，而这些实例能被同一方法控制的时候，我们就可以用蝇量模式
    //  蝇量模式的缺点在于，一旦你实现了它，那么单个的逻辑实例将无法拥有独立而不同的行为

    //  5.解释器
    //  使用解释器模式为语言创建解释器
    //  解释器模式的优点：
    //  - 将一个语法规则表示成一个类，方便与实现语言
    //  - 因为语法由许多类表示，所以你可以轻易地改变或扩展此语言
    //  - 通过在类的结构中加入新的方法，例如打印格式的美化或者进行复杂的程序验证
    //  解释器的用途和缺点
    //  - 当你需要实现一个简单的语言时，使用解释器
    //  - 当你有一个简单的语法，而且简单比效率更重要时，使用解释器
    //  - 可以处理脚本语言和编程语言
    //  - 当语法规则的数目太大时，这个模式可能会变得非常繁杂。这种情况下，使用解析器/编译器可能更合适

    //  6.中介者
    //  使用中介者模式来几种相关对象之间的复杂沟通与控制方式
    //  中介者的优点：
    //  - 通过将对象彼此解耦，可以增加对象的复用性
    //  - 通过将控制逻辑集中，可以简化系统维护
    //  - 可以让对象之间说传递的消息变得简单且大幅减少
    //  中介者的用途
    //  - 中介者常常被用来协调相关的 GUI 组件
    //  - 中介者模式的缺点，如果设计不当，中介者对象本身会变得过于复杂

    //  7.备忘录
    //  当你需要让对象返回之间的状态时（例如，你的用户请求“撤销”），就使用备忘录模式
    //  备忘录的优点：
    //  - 将被存储的状态放在外面，不要和关键对象混在一起，这可以帮助解决内聚
    //  - 保持关键对象的数据封装
    //  - 提供了容易实现的恢复能力
    //  备忘录的用途和缺点：
    //  - 备忘录用于存储状态
    //  - 使用备忘录的缺点：存储和恢复状态的过程可能相当耗时
    //  - 在 Java 系统中，其实可以考虑使用序列化机制存储系统的状态

    //  8.原型
    //  当创建给定类的实例的过程很昂贵或很复杂时，就使用原型模式
    //  原型的优点：
    //  - 向客户隐藏制造新实例的复杂性
    //  - 提供让客户能够产生未知类型对象的选项
    //  - 在某些环境下，复制对象比创建新对象更有效
    //  原型的用途和缺点
    //  - 在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象时，可以考虑原型
    //  - 使用原型模式的缺点：对象的复制有时相当复杂

    //  9.访问者
    //  当你想要为一个对象的组合增加新的能力，且封装并不重要时，就使用访问者模式
    //  访问者的优点：
    //  - 允许你对组合结构加入新的操作，而无需改变结构本身
    //  - 想要加入新的操作，相对容易
    //  - 访问者所进行的操作，其代码是集中在一起的
    //  访问者的用途和缺点：
    //  - 当采用访问者模式的时候，就会打破组合类的封装
    //  - 因为游走的功能牵涉其中，所以对组合结构的改变就更加困难了
}
