单例模式
1.定义：
 - 确保某个只有一个实例，而且执行实例化并向整个系统提供整个实例
2.使用场景：
 - 确保某个类只有一个对象的场景，避免产生多个对象消耗过多的资源，或者某种类型的对象只应该有且只有一个
 - 例如：创建一个对象需要消耗的资源过多，如要访问 IO 和数据库等资源
3.实现单例的几个关键点：
 - 构造函数不对外开放，一般为 Private
 - 通过一个静态方法或者枚举返回单例类对象
 - 确保单例类的对象有且只有一个，尤其是在多线程环境下
 - 确保单例类对象在反序列化时不会重新构建对象
4.双重检测
 - 第一层判断主要是为了避免不必要的同步，第二层判断则是为了在 null 的情况下创建实例
 - 为什么要加 volatile 关键字，解释写在了 DoubleCheck 类中
5.默认枚举实例的创建是线程安全的，并且在任何情况下它都是只有一个单例
6.除了枚举之外，其他单例在序列化和反序列化的时候都会出现重新创建对象的情况，如果使用的是 Serializable 进行序列化，那么就
需要自己手动重写 readResolve() 防止反序列化创建新对象，从而让我们自己控制对象的反序列
7.Android 中的应用：
 - Context 中的 getService()
8.小结
 优点：
 - 由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁的创建、销毁时，而且创建或销毁时性能又无法优化，
 单例模式的优势就非常明显
 - 由于单例模式只生成一个实例，所以，少了系统的性能开销，当一个对象的产生需要比较多的资源时买入读取配置、产生其他依赖时，
 则可以通过
 - 单例模式可以避免资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作
 - 单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理
 缺点：
 - 单例模式议案没有借口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现
 - 单例对象如果持有 Context，那么很容易引发内存泄漏，此时需要注意传递给单例对象的 Context 对象，对好是 Application Context