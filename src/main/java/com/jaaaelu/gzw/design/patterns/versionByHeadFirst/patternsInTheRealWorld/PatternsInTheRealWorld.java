package com.jaaaelu.gzw.design.patterns.versionByHeadFirst.patternsInTheRealWorld;

public class PatternsInTheRealWorld {
    //  第十三章 与设计模式相处

    //  定义设计模式：模式是某情境下，针对某问题的某种解决方案
    //  情景就是应用某个模式的情况
    //  问题就是你想在某情景下达成的目标
    //  解决方案就是你说追求的：一个通用的设计，用来解决约束、达到目标
    //  你拥有一个对象的集合（情景），你需要注意走访每个对象，而且不需要理会集合的实现（问题），将迭代封装进分离的类中（解决方案）

    //  “如果你发现自己处于某个情境下，面对者所欲达到的目标被一群约束影响着的问题，然而，你能够应用某个设计，克服这些约
    //  束并达到该目标，将你领向某个解决方案。”

    //  连连看总结（书中的连连看）：
    //  - 装饰者：包装一个对象，以提供新的行为
    //  - 状态：封装了基于状态的行为，并使用委托在行为之间切换
    //  - 迭代器：在对象的集合之中游走，而不暴露集合的实现
    //  - 外观：简化一群类的接口
    //  - 策略：封装可以互换的行为，并使用委托来决定要使用哪一个
    //  - 代理：包装对象，以控制对此对象的访问
    //  - 工厂方法：由子类决定要创建的具体类是哪一个
    //  - 适配器：封装对象，并提供不同的接口
    //  - 观察者：让对象能够在状态改变时被通知
    //  - 模板方法：由子类决定如何实现一个算法中的步骤
    //  - 组合：客户用一致的方式处理对象集合和单个对象
    //  - 单件：确保有且只有一个对象被创建
    //  - 抽象工厂：允许客户创建对象的家族，而无需指定他们的具体类
    //  - 命令：封装请求成为对象

    //  模式分类初步了解：
    //  三大分类：
    //  - 创建型模式涉及到将对象实例化，这类模式都提供一个方法，将客户从需要实例化的对象中解耦
    //  - 行为型模式都涉及到类和对象如何交互及分配职责
    //  - 结构型模式可以让你的类或对象组合到更大结构中
    //  其他分类：
    //  - 类模式描述类之间的关系如何通过继承定义。类模式的关系是在编译时建立的
    //  - 对象模式描述的对象之间的组合关系，而且主要是利用组合定义。对象模式的关系通常在运行时建立，而且更加动态，更有弹
    //  性
    //  当然还会有别的分类，只是书中没有全部介绍到

    //  当你设计的时候，如果确定在你设计中可以利用某个模式解决问题，那么就使用这个模式。如果有更简单的解决方案，那么在决
    //  定使用模式之前应该先考虑这个方案。所以，当你设计时，尽可能地用最简单的方式解决问题

    //  一旦你找到一个看起来合适的模式，要先确定你是否能接受这个模式所带来的后果，以及对设计其他部分的影响

    //  重构的目标是改善其结构，而不是其行为，这时候你可以重新检查你的设计来看是否能够利用模式来让它拥有更好的结构。比方
    //  说，代码内充满了条件语句，这可能意味着需要使用状态模式，或者意味着，应该利用工厂模式将这些具体的依赖消除掉

    //  为了实际需要的扩展使用模式。不要只是为了假想的需要而使用模式
    //  简单才是王道，如果你不用模式就能够设计出更简单的方法，那就去干吧
    //  模式是工具而不是规则，需要被适当的调整以符合你的需求

    //  反模式：告诉你如果如何采用一个不好的解决方案解决一个问题
    //  真的有人愿意花时间将不好的解决方案整理总结么？如果老是有人用某个不好的解决方案处理某个问题，而通过整理总结，可以
    //  帮助其他开发人员避免犯同样的错误。那么可以通过这种方式解决方案，这样就是有价值的，而且会和好的解决方案一样有价值

    //  反模式的几个元素：
    //  - 反模式告诉我们为什么不好的解决方案会有吸引力。它最重要的工作之一，在于警告你不要陷入某种致命的诱惑
    //  - 反模式告诉你为何这个解决方案从长远看会造成不好的影响。
    //  - 反模式模式建议你改用其他的模式以提供更好的解决方案

    //  要点：
    //  - 让设计模式自然而然的出现在你的设计中，而不是为了使用而使用
    //  - 设计模式并非僵化的教条，你可以根据自己的需求采用或调整
    //  - 总是使用满足需要的最简单解决方案，不管它用不用模式
    //  - 学习设计模式的类目，可以帮你熟悉这些模式以及它们之间的关系
    //  - 模式的分类是将模式分成不同的群组，如果这么做对你有帮助，就采用吧
    //  - 你必须相当专注才能够成功一个模式的作家：这需要时间也需要耐心，同时还必须乐意做大量的精华动作
    //  - 请牢记：你所遇到的大多数的模式都是现有模式的变体，而非新的模式
    //  - 模式能够为你带来的最大好处之一是：让你的团队拥有共享词汇
    //  - 任何社群都有自己的行话，模式社群也是如此。别让这些行话绊着，在读完这本书之后，你已经能够应用大部分的行话了

    //  OO 原则回顾：
    //  - 封装变化
    //  - 多用组合，少用继承
    //  - 针对接口编程，不针对实现编程
    //  - 为交互对象之间的松耦合设计而努力
    //  - 类应该对扩展开放，对修改关闭
    //  - 依赖抽象，不要依赖具体类
    //  - 之和朋友交谈
    //  - 别找我，我会找你
    //  - 类应该只有一个改变的理由
}
