package com.jaaaelu.gzw.design.patterns.versionByHeadFirst.adapterPatternAndFacadePatterns;

public class AdapterPattern {
    //  第六章 适配器模式与外观模式

    //  还记得装饰者模式么？我们将对象包装起来，赋予他们新的职责。而现在则是以不同的，包装某些对象：让它们的接口看起来不
    //  像自己而像是别的东西
    //  为何要这样做？因为这样做就可以在设计中，将类的接口转换为想要的接口，以便实现不同的接口
    //  而外观模式用于将对象包装起来以简化其接口

    //  客户使用适配器的过程如下：
    //  - 客户通过目标接口调用适配器的方法对适配器发出请求
    //  - 适配器使用被是陪着接口把请求转换为被适配者一个或多个调用接口（例子中火鸡是被适配者接口）
    //  - 客户端解手到调用的结果，但并未察觉这一切是适配器在起作用
    //  （客户端和被适配者是解耦的某一个不知道另一个）

    //  如果不用适配器，你就必须改写客户端的代码来调用这个新的接口，将会花许多力气来做大量的调查工作和代码改写工作。相比
    //  之下，提供一个适配器类，将所有的改变封装在一个类中是比较好的做法

    //  适配器模式：将一类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容类可以合作无间
    //  实际上有“两种”适配器：“对象”适配器和“类”适配器，唯一的差别就在于适配器继承了目标接口和被适配者。而对象适配
    //  器利用组合的方式将请求传送给被适配者（就像前面火鸡和鸭子）

    //  连连看总结（书中的连连看）：
    //  - 装饰者：不改变接口，但加入责任
    //  - 适配器：建一个接口转成另一个接口
    //  - 外观：让接口更简单

    //  外观模式的一个的特征是：提供简化的接口的同时，依然将系统完整的功能暴露出来，一共需要的人使用

    //  两个模式（适配器模式与外观模式）的差异，不在于他们“包装”了几个类，而是在于它们的意图。适配器模式的意图是，“改变”
    //  接口符合客户的期望；而外观模式的意图是，提供子系统的一个简化接口

    //  外观模式：提供了一个统一的接口，用来访问子系统个中的一群接口。外观定义了一个高层接口，让子系统更容易使用

    //  外观模式允许我们让客户端和子系统之间避免紧耦合

    //  设计原则
    //  1.最少知识原则：只和你的密友谈话（当你正在设计一个系统，不管是任何对象，你都要注意它所交互的类有哪些，并注意它和
    //  这些类是如何交互的）（这个原则希望我们在设计中，不要让太多的类耦合再一起，免得修改系统一部分，会影响到其他部分。
    //  如果许多类之间互相依赖，那么这个系统就会辩护词呢个一个易碎的系统，它需要需要成本维护，也会因为太复杂而不容易被他
    //  人了解）

    //  如何你要赢得太多的朋友和影响太多的对象？这个原则提供了一些方针：只调用属于以下范围的方法：
    //  - 该对象本身
    //  - 被当做方法的参数而传递进来的对象
    //  - 此方法所创建或实例化的任何对象
    //  - 对象的任何组件（组合的）

    //  如果调用从另一个调用中返回的对象的方法，会有什么害处呢？如果我们这样做，相当于向另一个对象的子部分发请求（而增加
    //  我们直接认识的对象数目）。在这种情况下，原则要我们改为要求该对象为我们做出请求，这么一来，我们就不需要认识该对象
    //  的组件了。也就是说 a.b().c(); 可以改为 a.d(); d() 为 b().c();

    //  事实上，没有任何原则是法律，所有的原则都应该在有帮助的时候才遵守

    //  最少只是有什么缺点：
    //  虽然这个原则减少了对象之间的依赖，研究显示这个会减少软件的维护成本；但是采用和这个原则也会导致更多的“包装”类被
    //  制造出来，以处理和其他组件的沟通，这个会导致复杂度和开发时间的增加，并降低运行时的性能

    //  要点：
    //  - 当需要使用一个现有类而其接口并不符合你的需求时，就是用适配器
    //  - 当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观模式
    //  - 适配器改变接口以符合客户的期望
    //  - 外观将客户从一个复杂的子系统中解耦
    //  - 实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定
    //  - 实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行
    //  - 适配器模式有种形式：对象适配器和类适配器。类适配器需要用到多重继承
    //  - 你可以为一个子系统实现一个以上的外观
    //  - 适配器将一个对象包装起来以改变其接口；装饰者将一个对象包装起来以增加新的行为和责任；而外观模式将一群对象“包装”
    //  起来以简化其接口
}
